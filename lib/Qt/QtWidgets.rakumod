# 
# This code has been automatically generated by RaQt_maker V0.0.1.
# 
# Rather than manually modify this file, it should be preferable to
# 
#     - 1) Modify the source files available here:
#         https://github.com/yguillemot/RaQt_maker.git
# 
#     - 2) Regenerate the whole code.
# 
unit module QtWidgets;

# TODO : Est-ce que l'Id donnÃ© aux objets QtObject est utile ?
#        Pourquoi ne pas utiliser le pointeur vers l'objet C++ du wrapper ?

use NativeCall;
use Qt::QtWidgets::QtHelpers;
use Qt::QtWidgets::QtWrappers;

our %signals;    # className -> @[SigSlot( "signal(signature)", isSimpleSig )]
our %slots;
our %callbacks;  # classname -> @virtualMethodName 

# TODO : Move into Qt::RaQt::RaQtHelpers
class SigSlot {
    has Str $.name;
    has Str $.sig;      # Raku reduced signature string
    has Str $.qSig;     # Qt C++ reduced signature string
    has Bool $.sigIsSimple;
    has SSignature $.sSignature is rw;
    has Bool $.isSlot;
    has Bool $.isPlainQt;
    has Bool $.isPrivate = False;        # Only for signals
}

BEGIN {
    %signals<QtWidgets::QAbstractButton>.push(SigSlot.new(
        name => "pressed",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => False,
        isPrivate => False,
        sSignature => createSignature(())
    ));
    %signals<QtWidgets::QAbstractButton>.push(SigSlot.new(
        name => "clicked",
        sig => "(Bool)",
        qSig => "(bool)",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => False,
        isPrivate => False,
        sSignature => createSignature((("Bool" ,"checked", False), ))
    ));
    %signals<QtWidgets::QAction>.push(SigSlot.new(
        name => "triggered",
        sig => "(Bool)",
        qSig => "(bool)",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => False,
        isPrivate => False,
        sSignature => createSignature((("Bool" ,"checked", False), ))
    ));
    %signals<QtWidgets::QLineEdit>.push(SigSlot.new(
        name => "returnPressed",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => False,
        isPrivate => False,
        sSignature => createSignature(())
    ));
    %signals<QtWidgets::QLineEdit>.push(SigSlot.new(
        name => "editingFinished",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => False,
        isPrivate => False,
        sSignature => createSignature(())
    ));
    %signals<QtWidgets::QTimer>.push(SigSlot.new(
        name => "timeout",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => False,
        isPrivate => True,
        sSignature => createSignature(())
    ));


    %slots<QtWidgets::QWidget>.push(SigSlot.new(
        name => "setDisabled",
        sig => "(Bool)",
        qSig => "(bool)",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(("Bool", ))
    ));
    %slots<QtWidgets::QWidget>.push(SigSlot.new(
        name => "setWindowTitle",
        sig => "(Str)",
        qSig => "(const QString&)",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(("Str", ))
    ));
    %slots<QtWidgets::QWidget>.push(SigSlot.new(
        name => "setFocus",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));
    %slots<QtWidgets::QWidget>.push(SigSlot.new(
        name => "update",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));
    %slots<QtWidgets::QWidget>.push(SigSlot.new(
        name => "show",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));
    %slots<QtWidgets::QAbstractButton>.push(SigSlot.new(
        name => "click",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));
    %slots<QtWidgets::QAction>.push(SigSlot.new(
        name => "trigger",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));
    %slots<QtWidgets::QAction>.push(SigSlot.new(
        name => "setEnabled",
        sig => "(Bool)",
        qSig => "(bool)",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(("Bool", ))
    ));
    %slots<QtWidgets::QAction>.push(SigSlot.new(
        name => "setDisabled",
        sig => "(Bool)",
        qSig => "(bool)",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(("Bool", ))
    ));
    %slots<QtWidgets::QCoreApplication>.push(SigSlot.new(
        name => "quit",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));
    %slots<QtWidgets::QLineEdit>.push(SigSlot.new(
        name => "setText",
        sig => "(Str)",
        qSig => "(const QString&)",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(("Str", ))
    ));
    %slots<QtWidgets::QLineEdit>.push(SigSlot.new(
        name => "clear",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));
    %slots<QtWidgets::QTimer>.push(SigSlot.new(
        name => "start",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));
    %slots<QtWidgets::QTimer>.push(SigSlot.new(
        name => "stop",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));
    %slots<QtWidgets::QLabel>.push(SigSlot.new(
        name => "setText",
        sig => "(Str)",
        qSig => "(const QString&)",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(("Str", ))
    ));
    %slots<QtWidgets::QLabel>.push(SigSlot.new(
        name => "clear",
        sig => "()",
        qSig => "()",
        sigIsSimple => True,
        isPlainQt => True,
        isSlot => True,
        sSignature => createSignature(())
    ));

}



# BEWARE : For some reason, class Sigsloty is compiled BEFORE other classes
#          May be the cause is the import instruction?


# Predeclaration of classes to avoid problems with potential cross references

class QAbstractButton { ... }
class QAbstractScrollArea { ... }
class QAction { ... }
class QBoxLayout { ... }
class QBrush { ... }
class QColor { ... }
class QCoreApplication { ... }
class QEvent { ... }
class QFont { ... }
class QFrame { ... }
class QGuiApplication { ... }
class QHBoxLayout { ... }
class QImage { ... }
class QInputEvent { ... }
class QLabel { ... }
class QLayout { ... }
class QLayoutItem { ... }
class QLineEdit { ... }
class QMenu { ... }
class QMouseEvent { ... }
class QObject { ... }
class QPaintDevice { ... }
class QPaintEvent { ... }
class QPainter { ... }
class QPen { ... }
class QPoint { ... }
class QPointF { ... }
class QPushButton { ... }
class QRect { ... }
class QRegion { ... }
class QTextEdit { ... }
class QTimer { ... }
class QVBoxLayout { ... }
class QWidget { ... }
class Qt { ... }


class ConnectionsManager { ... };
class QApplication { ... };
my ConnectionsManager $CM;   # Where global values are stored
my QApplication $QA;         


# This class is parent of everything related to Qt
class QtBase {

    has Pointer $.address is rw;
    has Bool $.ownedByRaku is rw;

    method validateCallBacks()
    {
        for self.^parents>>.raku -> $cl {
            next if %callbacks{$cl}:!exists;
            for |%callbacks{$cl} -> $cb {
                for self.^methods>>.name -> $m {
                    if $m eq $cb {
                        # Valid callback $cb (or $m) of class $cl
                        # TODO : Pas tres clair dans QWtrapper.hpp ...
                        self.validateCB($m);
                   }
                }
            }
        }
    }

}




###############################################################################
####### Part 1 : sub API ######################################################

### Beginning of the sub API part ###
class Qt is QtBase is export {
    enum AlignmentFlag (
        AlignLeft => 1,
        AlignLeading => 1,
        AlignRight => 2,
        AlignTrailing => 2,
        AlignHCenter => 4,
        AlignJustify => 8,
        AlignAbsolute => 16,
        AlignHorizontal_Mask => 31,
        AlignTop => 32,
        AlignBottom => 64,
        AlignVCenter => 128,
        AlignBaseline => 256,
        AlignVertical_Mask => 480,
        AlignCenter => 132,
    );
    our sub Alignment($e? = AlignLeft --> Int ) is export { $e };
    enum BrushStyle (
        NoBrush => 0,
        SolidPattern => 1,
        Dense1Pattern => 2,
        Dense2Pattern => 3,
        Dense3Pattern => 4,
        Dense4Pattern => 5,
        Dense5Pattern => 6,
        Dense6Pattern => 7,
        Dense7Pattern => 8,
        HorPattern => 9,
        VerPattern => 10,
        CrossPattern => 11,
        BDiagPattern => 12,
        FDiagPattern => 13,
        DiagCrossPattern => 14,
        LinearGradientPattern => 15,
        RadialGradientPattern => 16,
        ConicalGradientPattern => 17,
        TexturePattern => 24,
    );
    enum FocusPolicy (
        NoFocus => 0,
        TabFocus => 1,
        ClickFocus => 2,
        StrongFocus => 11,
        WheelFocus => 15,
    );
    enum FocusReason (
        MouseFocusReason => 0,
        TabFocusReason => 1,
        BacktabFocusReason => 2,
        ActiveWindowFocusReason => 3,
        PopupFocusReason => 4,
        ShortcutFocusReason => 5,
        MenuBarFocusReason => 6,
        OtherFocusReason => 7,
        NoFocusReason => 8,
    );
    enum GlobalColor (
        color0 => 0,
        color1 => 1,
        black => 2,
        white => 3,
        darkGray => 4,
        gray => 5,
        lightGray => 6,
        red => 7,
        green => 8,
        blue => 9,
        cyan => 10,
        magenta => 11,
        yellow => 12,
        darkRed => 13,
        darkGreen => 14,
        darkBlue => 15,
        darkCyan => 16,
        darkMagenta => 17,
        darkYellow => 18,
        transparent => 19,
    );
    enum KeyboardModifier (
        NoModifier => 0,
        ShiftModifier => 33554432,
        ControlModifier => 67108864,
        AltModifier => 134217728,
        MetaModifier => 268435456,
        KeypadModifier => 536870912,
        GroupSwitchModifier => 1073741824,
        KeyboardModifierMask => 4261412864,
    );
    our sub KeyboardModifiers($e? = NoModifier --> Int ) is export { $e };
    enum MouseButton (
        NoButton => 0,
        LeftButton => 1,
        RightButton => 2,
        MidButton => 4,
        MiddleButton => 4,
        BackButton => 8,
        XButton1 => 8,
        ExtraButton1 => 8,
        ForwardButton => 16,
        XButton2 => 16,
        ExtraButton2 => 16,
        TaskButton => 32,
        ExtraButton3 => 32,
        ExtraButton4 => 64,
        ExtraButton5 => 128,
        ExtraButton6 => 256,
        ExtraButton7 => 512,
        ExtraButton8 => 1024,
        ExtraButton9 => 2048,
        ExtraButton10 => 4096,
        ExtraButton11 => 8192,
        ExtraButton12 => 16384,
        ExtraButton13 => 32768,
        ExtraButton14 => 65536,
        ExtraButton15 => 131072,
        ExtraButton16 => 262144,
        ExtraButton17 => 524288,
        ExtraButton18 => 1048576,
        ExtraButton19 => 2097152,
        ExtraButton20 => 4194304,
        ExtraButton21 => 8388608,
        ExtraButton22 => 16777216,
        ExtraButton23 => 33554432,
        ExtraButton24 => 67108864,
        AllButtons => 134217727,
        MaxMouseButton => 67108864,
        MouseButtonMask => 4294967295,
    );
    our sub MouseButtons($e? = NoButton --> Int ) is export { $e };
    enum MouseEventSource (
        MouseEventNotSynthesized => 0,
        MouseEventSynthesizedBySystem => 1,
        MouseEventSynthesizedByQt => 2,
        MouseEventSynthesizedByApplication => 3,
    );
    enum PenStyle (
        NoPen => 0,
        SolidLine => 1,
        DashLine => 2,
        DotLine => 3,
        DashDotLine => 4,
        DashDotDotLine => 5,
        CustomDashLine => 6,
        MPenStyle => 15,
    );
    enum TextFormat (
        PlainText => 0,
        RichText => 1,
        AutoText => 2,
    );
    enum WindowType (
        Widget => 0,
        Window => 1,
        Dialog => 3,
        Sheet => 5,
        Drawer => 7,
        Popup => 9,
        Tool => 11,
        ToolTip => 13,
        SplashScreen => 15,
        Desktop => 17,
        SubWindow => 18,
        ForeignWindow => 33,
        CoverWindow => 65,
        WindowType_Mask => 255,
        MSWindowsFixedSizeDialogHint => 256,
        MSWindowsOwnDC => 512,
        BypassWindowManagerHint => 1024,
        X11BypassWindowManagerHint => 1024,
        FramelessWindowHint => 2048,
        WindowTitleHint => 4096,
        WindowSystemMenuHint => 8192,
        WindowMinimizeButtonHint => 16384,
        WindowMaximizeButtonHint => 32768,
        WindowMinMaxButtonsHint => 49152,
        WindowContextHelpButtonHint => 65536,
        WindowShadeButtonHint => 131072,
        WindowStaysOnTopHint => 262144,
        WindowTransparentForInput => 524288,
        WindowOverridesSystemGestures => 1048576,
        WindowDoesNotAcceptFocus => 2097152,
        MaximizeUsingFullscreenGeometryHint => 4194304,
        CustomizeWindowHint => 33554432,
        WindowStaysOnBottomHint => 67108864,
        WindowCloseButtonHint => 134217728,
        MacWindowToolBarButtonHint => 268435456,
        BypassGraphicsProxyWidget => 536870912,
        NoDropShadowWindowHint => 1073741824,
        WindowFullscreenButtonHint => 2147483648,
    );
    our sub WindowFlags($e? = Widget --> Int ) is export { $e };
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = False;
    }
    multi sub ctor(|capture) is hidden-from-backtrace {
        unimplementedCtor("Qt");
    }
    submethod new(|capture) {
        my Qt $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
}

class QEvent is QtBase is export {
    enum Type (
        None => 0,
        Timer => 1,
        MouseButtonPress => 2,
        MouseButtonRelease => 3,
        MouseButtonDblClick => 4,
        MouseMove => 5,
        KeyPress => 6,
        KeyRelease => 7,
        FocusIn => 8,
        FocusOut => 9,
        FocusAboutToChange => 23,
        Enter => 10,
        Leave => 11,
        Paint => 12,
        Move => 13,
        Resize => 14,
        Create => 15,
        Destroy => 16,
        Show => 17,
        Hide => 18,
        Close => 19,
        Quit => 20,
        ParentChange => 21,
        ParentAboutToChange => 131,
        ThreadChange => 22,
        WindowActivate => 24,
        WindowDeactivate => 25,
        ShowToParent => 26,
        HideToParent => 27,
        Wheel => 31,
        WindowTitleChange => 33,
        WindowIconChange => 34,
        ApplicationWindowIconChange => 35,
        ApplicationFontChange => 36,
        ApplicationLayoutDirectionChange => 37,
        ApplicationPaletteChange => 38,
        PaletteChange => 39,
        Clipboard => 40,
        Speech => 42,
        MetaCall => 43,
        SockAct => 50,
        WinEventAct => 132,
        DeferredDelete => 52,
        DragEnter => 60,
        DragMove => 61,
        DragLeave => 62,
        Drop => 63,
        DragResponse => 64,
        ChildAdded => 68,
        ChildPolished => 69,
        ChildRemoved => 71,
        ShowWindowRequest => 73,
        PolishRequest => 74,
        Polish => 75,
        LayoutRequest => 76,
        UpdateRequest => 77,
        UpdateLater => 78,
        EmbeddingControl => 79,
        ActivateControl => 80,
        DeactivateControl => 81,
        ContextMenu => 82,
        InputMethod => 83,
        TabletMove => 87,
        LocaleChange => 88,
        LanguageChange => 89,
        LayoutDirectionChange => 90,
        Style => 91,
        TabletPress => 92,
        TabletRelease => 93,
        OkRequest => 94,
        HelpRequest => 95,
        IconDrag => 96,
        FontChange => 97,
        EnabledChange => 98,
        ActivationChange => 99,
        StyleChange => 100,
        IconTextChange => 101,
        ModifiedChange => 102,
        MouseTrackingChange => 109,
        WindowBlocked => 103,
        WindowUnblocked => 104,
        WindowStateChange => 105,
        ReadOnlyChange => 106,
        ToolTip => 110,
        WhatsThis => 111,
        StatusTip => 112,
        ActionChanged => 113,
        ActionAdded => 114,
        ActionRemoved => 115,
        FileOpen => 116,
        Shortcut => 117,
        ShortcutOverride => 51,
        WhatsThisClicked => 118,
        ToolBarChange => 120,
        ApplicationActivate => 121,
        ApplicationActivated => 121,
        ApplicationDeactivate => 122,
        ApplicationDeactivated => 122,
        QueryWhatsThis => 123,
        EnterWhatsThisMode => 124,
        LeaveWhatsThisMode => 125,
        ZOrderChange => 126,
        HoverEnter => 127,
        HoverLeave => 128,
        HoverMove => 129,
        AcceptDropsChange => 152,
        ZeroTimerEvent => 154,
        GraphicsSceneMouseMove => 155,
        GraphicsSceneMousePress => 156,
        GraphicsSceneMouseRelease => 157,
        GraphicsSceneMouseDoubleClick => 158,
        GraphicsSceneContextMenu => 159,
        GraphicsSceneHoverEnter => 160,
        GraphicsSceneHoverMove => 161,
        GraphicsSceneHoverLeave => 162,
        GraphicsSceneHelp => 163,
        GraphicsSceneDragEnter => 164,
        GraphicsSceneDragMove => 165,
        GraphicsSceneDragLeave => 166,
        GraphicsSceneDrop => 167,
        GraphicsSceneWheel => 168,
        KeyboardLayoutChange => 169,
        DynamicPropertyChange => 170,
        TabletEnterProximity => 171,
        TabletLeaveProximity => 172,
        NonClientAreaMouseMove => 173,
        NonClientAreaMouseButtonPress => 174,
        NonClientAreaMouseButtonRelease => 175,
        NonClientAreaMouseButtonDblClick => 176,
        MacSizeChange => 177,
        ContentsRectChange => 178,
        MacGLWindowChange => 179,
        FutureCallOut => 180,
        GraphicsSceneResize => 181,
        GraphicsSceneMove => 182,
        CursorChange => 183,
        ToolTipChange => 184,
        NetworkReplyUpdated => 185,
        GrabMouse => 186,
        UngrabMouse => 187,
        GrabKeyboard => 188,
        UngrabKeyboard => 189,
        MacGLClearDrawable => 191,
        StateMachineSignal => 192,
        StateMachineWrapped => 193,
        TouchBegin => 194,
        TouchUpdate => 195,
        TouchEnd => 196,
        NativeGesture => 197,
        RequestSoftwareInputPanel => 199,
        CloseSoftwareInputPanel => 200,
        WinIdChange => 203,
        Gesture => 198,
        GestureOverride => 202,
        ScrollPrepare => 204,
        Scroll => 205,
        Expose => 206,
        InputMethodQuery => 207,
        OrientationChange => 208,
        TouchCancel => 209,
        ThemeChange => 210,
        SockClose => 211,
        PlatformPanel => 212,
        StyleAnimationUpdate => 213,
        ApplicationStateChange => 214,
        WindowChangeInternal => 215,
        ScreenChangeInternal => 216,
        PlatformSurface => 217,
        Pointer => 218,
        TabletTrackingChange => 219,
        User => 1000,
        MaxUser => 65535,
    );
    multi sub ctor(QtBase $this, QEvent::Type $type) {
        $this.address = QWQEventCtor_1($type);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, QEvent $other) {
        my $a1 = $other.address;
        $this.address = QWQEventCtor_2($a1);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QEvent $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQEventDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method type( --> QEvent::Type)
    {
        my $result = QWQEventtype(self.address);
        my $result1 = QEvent::Type($result);
        return $result1;
    }
    method spontaneous( --> Bool)
    {
        my $result = QWQEventspontaneous(self.address);
        my $result1 = ?$result;
        return $result1;
    }
    method isAccepted( --> Bool)
    {
        my $result = QWQEventisAccepted(self.address);
        my $result1 = ?$result;
        return $result1;
    }
    method accept()
    {
        QWQEventaccept(self.address);
    }
    method ignore()
    {
        QWQEventignore(self.address);
    }
}

class QInputEvent is QEvent is export {
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = False;
    }
    multi sub ctor(|capture) is hidden-from-backtrace {
        unimplementedCtor("QInputEvent");
    }
    submethod new(|capture) {
        my QInputEvent $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
}

class QPaintEvent is QEvent is export {
    multi sub ctor(QtBase $this, QRect $paintRect) {
        my $a1 = $paintRect.address;
        $this.address = QWQPaintEventCtor_2($a1);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QPaintEvent $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQPaintEventDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method rect( --> QRect)
    {
        my $result = QWQPaintEventrect(self.address);
        my $result1 = QRect.new($result, obr => False);
        return $result1;
    }
}

class QMouseEvent is QInputEvent is export {
    multi sub ctor(QtBase $this, QEvent::Type $type, QPointF $localPos, Qt::MouseButton $button, Int $buttons, Int $modifiers) {
        my $a2 = $localPos.address;
        $this.address = QWQMouseEventCtor_1($type, $a2, $button, $buttons, $modifiers);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, QEvent::Type $type, QPointF $localPos, QPointF $screenPos, Qt::MouseButton $button, Int $buttons, Int $modifiers) {
        my $a2 = $localPos.address;
        my $a3 = $screenPos.address;
        $this.address = QWQMouseEventCtor_2($type, $a2, $a3, $button, $buttons, $modifiers);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, QEvent::Type $type, QPointF $localPos, QPointF $windowPos, QPointF $screenPos, Qt::MouseButton $button, Int $buttons, Int $modifiers) {
        my $a2 = $localPos.address;
        my $a3 = $windowPos.address;
        my $a4 = $screenPos.address;
        $this.address = QWQMouseEventCtor_3($type, $a2, $a3, $a4, $button, $buttons, $modifiers);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, QEvent::Type $type, QPointF $localPos, QPointF $windowPos, QPointF $screenPos, Qt::MouseButton $button, Int $buttons, Int $modifiers, Qt::MouseEventSource $source) {
        my $a2 = $localPos.address;
        my $a3 = $windowPos.address;
        my $a4 = $screenPos.address;
        $this.address = QWQMouseEventCtor_4($type, $a2, $a3, $a4, $button, $buttons, $modifiers, $source);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QMouseEvent $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQMouseEventDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method x( --> Int)
    {
        my $result = QWQMouseEventx(self.address);
        return $result;
    }
    method y( --> Int)
    {
        my $result = QWQMouseEventy(self.address);
        return $result;
    }
    method button( --> Qt::MouseButton)
    {
        my $result = QWQMouseEventbutton(self.address);
        my $result1 = Qt::MouseButton($result);
        return $result1;
    }
}

class QBrush is QtBase is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQBrushCtor_1();
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, Qt::BrushStyle $bs) {
        $this.address = QWQBrushCtor_2($bs);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, QColor $color, Qt::BrushStyle $bs = Qt::SolidPattern) {
        my $a1 = $color.address;
        $this.address = QWQBrushCtor_3($a1, $bs);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QBrush $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQBrushDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method setStyle(Qt::BrushStyle $arg1)
    {
        QWQBrushsetStyle(self.address, $arg1);
    }
    multi method setColor(QColor $color)
    {
        my $a1 = $color.address;
        QWQBrushsetColor_1(self.address, $a1);
    }
}

class QColor is QtBase is export {
    multi sub ctor(QtBase $this, Qt::GlobalColor $color) {
        $this.address = QWQColorCtor_2($color);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, Int $r, Int $g, Int $b, Int $a = 255) {
        $this.address = QWQColorCtor_3($r, $g, $b, $a);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QColor $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQColorDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method alpha( --> Int)
    {
        my $result = QWQColoralpha(self.address);
        return $result;
    }
    method red( --> Int)
    {
        my $result = QWQColorred(self.address);
        return $result;
    }
    method green( --> Int)
    {
        my $result = QWQColorgreen(self.address);
        return $result;
    }
    method blue( --> Int)
    {
        my $result = QWQColorblue(self.address);
        return $result;
    }
}

class QFont is QtBase is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQFontCtor_1();
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QFont $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQFontDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method setFamily(Str $arg1)
    {
        QWQFontsetFamily(self.address, $arg1);
    }
    method setPointSize(Int $arg1)
    {
        QWQFontsetPointSize(self.address, $arg1);
    }
    method setBold(Bool $arg1)
    {
        my int8 $a1 = $arg1.Int;
        QWQFontsetBold(self.address, $a1);
    }
    method setItalic(Bool $b)
    {
        my int8 $a1 = $b.Int;
        QWQFontsetItalic(self.address, $a1);
    }
}

class QPainter is QtBase is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQPainterCtor_1();
        $this.ownedByRaku = True;
    }

multi sub ctor(QtBase $this, QPaintDevice $arg1) {
    if !$arg1 {
        ctor($this);
        return;
    }

    given $arg1 {
        when QLabel {
            $this.address = QWQPainterCtor_QWidget($arg1.addres);
        }
        when QWidget {
            $this.address = QWQPainterCtor_QWidget($arg1.addres);
        }
        when QImage {
            $this.address = QWQPainterCtor_QImage($arg1.addres);
        }
        default {
            die "QPainter({$arg1.WHAT} is unsupported";
        }
    }

    $this.ownedByRaku = True;
}
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QPainter $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQPainterDtor(self.address);
            self.ownedByRaku = False;
        }
    }

method begin(QPaintDevice $arg1 --> Bool) {
    if !$arg1 {
        return ?QWQPainterbegin_null(self.address);
    }

    given $arg1 {
        when QLabel  {
            return ?QWQPainterbegin_QWidget(self.address, $arg1.address);
        }
        when QWidget  {
            return ?QWQPainterbegin_QWidget(self.address, $arg1.address);
        }
        when QImage {
            return ?QWQPainterbegin_QImage(self.address, $arg1.address);
        }
        default {
            note "QPainter::begin : arg type {$arg1.WHAT} is unsupported";
            die "QPainter({$arg1.WHAT}) is unsupported";
        }
    }
}

    method end( --> Bool)
    {
        my $result = QWQPainterend(self.address);
        my $result1 = ?$result;
        return $result1;
    }
    multi method setPen(QColor $color)
    {
        my $a1 = $color.address;
        QWQPaintersetPen_1(self.address, $a1);
    }
    multi method setPen(QPen $pen)
    {
        my $a1 = $pen.address;
        QWQPaintersetPen_2(self.address, $a1);
    }
    multi method setPen(Qt::PenStyle $style)
    {
        QWQPaintersetPen_3(self.address, $style);
    }
    multi method setBrush(QBrush $brush)
    {
        my $a1 = $brush.address;
        QWQPaintersetBrush_1(self.address, $a1);
    }
    method save()
    {
        QWQPaintersave(self.address);
    }
    method restore()
    {
        QWQPainterrestore(self.address);
    }
    multi method drawLine(Int $x1, Int $y1, Int $x2, Int $y2)
    {
        QWQPainterdrawLine_3(self.address, $x1, $y1, $x2, $y2);
    }
    multi method drawRect(Int $x1, Int $y1, Int $w, Int $h)
    {
        QWQPainterdrawRect_2(self.address, $x1, $y1, $w, $h);
    }
    multi method drawEllipse(Int $x, Int $y, Int $w, Int $h)
    {
        QWQPainterdrawEllipse_3(self.address, $x, $y, $w, $h);
    }
}

class QPen is QtBase is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQPenCtor_1();
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, Qt::PenStyle $arg1) {
        $this.address = QWQPenCtor_2($arg1);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, QColor $color) {
        my $a1 = $color.address;
        $this.address = QWQPenCtor_3($a1);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QPen $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQPenDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method setWidth(Int $width)
    {
        QWQPensetWidth(self.address, $width);
    }
    method setColor(QColor $color)
    {
        my $a1 = $color.address;
        QWQPensetColor(self.address, $a1);
    }
    method setBrush(QBrush $brush)
    {
        my $a1 = $brush.address;
        QWQPensetBrush(self.address, $a1);
    }
}

class QPoint is QtBase is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQPointCtor_1();
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, Int $xpos, Int $ypos) {
        $this.address = QWQPointCtor_2($xpos, $ypos);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QPoint $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQPointDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method isNull( --> Bool)
    {
        my $result = QWQPointisNull(self.address);
        my $result1 = ?$result;
        return $result1;
    }
    method x( --> Int)
    {
        my $result = QWQPointx(self.address);
        return $result;
    }
    method y( --> Int)
    {
        my $result = QWQPointy(self.address);
        return $result;
    }
    method setX(Int $x)
    {
        QWQPointsetX(self.address, $x);
    }
    method setY(Int $y)
    {
        QWQPointsetY(self.address, $y);
    }
    method manhattanLength( --> Int)
    {
        my $result = QWQPointmanhattanLength(self.address);
        return $result;
    }
}

class QPointF is QtBase is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQPointFCtor_1();
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, QPoint $p) {
        my $a1 = $p.address;
        $this.address = QWQPointFCtor_2($a1);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, Real $xpos, Real $ypos) {
        my Num $a1 = $xpos.Num;
        my Num $a2 = $ypos.Num;
        $this.address = QWQPointFCtor_3($a1, $a2);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QPointF $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQPointFDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method manhattanLength( --> Real)
    {
        my $result = QWQPointFmanhattanLength(self.address);
        my $result1 = $result.Real;
        return $result1;
    }
    method isNull( --> Bool)
    {
        my $result = QWQPointFisNull(self.address);
        my $result1 = ?$result;
        return $result1;
    }
    method x( --> Real)
    {
        my $result = QWQPointFx(self.address);
        my $result1 = $result.Real;
        return $result1;
    }
    method y( --> Real)
    {
        my $result = QWQPointFy(self.address);
        my $result1 = $result.Real;
        return $result1;
    }
    method setX(Real $x)
    {
        my Num $a1 = $x.Num;
        QWQPointFsetX(self.address, $a1);
    }
    method setY(Real $y)
    {
        my Num $a1 = $y.Num;
        QWQPointFsetY(self.address, $a1);
    }
}

class QRect is QtBase is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQRectCtor_1();
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, QPoint $topleft, QPoint $bottomright) {
        my $a1 = $topleft.address;
        my $a2 = $bottomright.address;
        $this.address = QWQRectCtor_2($a1, $a2);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, Int $left, Int $top, Int $width, Int $height) {
        $this.address = QWQRectCtor_4($left, $top, $width, $height);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QRect $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQRectDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method x( --> Int)
    {
        my $result = QWQRectx(self.address);
        return $result;
    }
    method y( --> Int)
    {
        my $result = QWQRecty(self.address);
        return $result;
    }
    method width( --> Int)
    {
        my $result = QWQRectwidth(self.address);
        return $result;
    }
    method height( --> Int)
    {
        my $result = QWQRectheight(self.address);
        return $result;
    }
}

class QRegion is QtBase is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQRegionCtor_1();
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QRegion $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQRegionDtor(self.address);
            self.ownedByRaku = False;
        }
    }
}

class QPaintDevice is QtBase is export {
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = False;
    }
    multi sub ctor(|capture) is hidden-from-backtrace {
        unimplementedCtor("QPaintDevice");
    }
    submethod new(|capture) {
        my QPaintDevice $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
}

class QImage is QPaintDevice is export {
    enum Format (
        Format_Invalid => 0,
        Format_Mono => 1,
        Format_MonoLSB => 2,
        Format_Indexed8 => 3,
        Format_RGB32 => 4,
        Format_ARGB32 => 5,
        Format_ARGB32_Premultiplied => 6,
        Format_RGB16 => 7,
        Format_ARGB8565_Premultiplied => 8,
        Format_RGB666 => 9,
        Format_ARGB6666_Premultiplied => 10,
        Format_RGB555 => 11,
        Format_ARGB8555_Premultiplied => 12,
        Format_RGB888 => 13,
        Format_RGB444 => 14,
        Format_ARGB4444_Premultiplied => 15,
        Format_RGBX8888 => 16,
        Format_RGBA8888 => 17,
        Format_RGBA8888_Premultiplied => 18,
        Format_BGR30 => 19,
        Format_A2BGR30_Premultiplied => 20,
        Format_RGB30 => 21,
        Format_A2RGB30_Premultiplied => 22,
        Format_Alpha8 => 23,
        Format_Grayscale8 => 24,
        NImageFormats => 25,
    );
    multi sub ctor(QtBase $this, Int $width, Int $height, QImage::Format $format) {
        $this.address = QWQImageCtor_3($width, $height, $format);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QImage $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQImageDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method width( --> Int)
    {
        my $result = QWQImagewidth(self.address);
        return $result;
    }
    method height( --> Int)
    {
        my $result = QWQImageheight(self.address);
        return $result;
    }
    multi method pixelColor(Int $x, Int $y --> QColor)
    {
        my $result = QWQImagepixelColor_1(self.address, $x, $y);
        my $result1 = QColor.new($result, obr => True);
        return $result1;
    }
    multi method fill(QColor $color)
    {
        my $a1 = $color.address;
        QWQImagefill_2(self.address, $a1);
    }
}

class QLayoutItem is QtBase is export {
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = False;
    }
    multi sub ctor(|capture) is hidden-from-backtrace {
        unimplementedCtor("QLayoutItem");
    }
    submethod new(|capture) {
        my QLayoutItem $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
}
### End of the sub API part ###



###############################################################################
###############################################################################





############################################################################
############################################################################


# Store a pointer to some related object in Qt library and manage
# the signals and slots
class Sigsloty is QtBase is export {

#     say 'INIT @signals';

    ##################################################################
    ### ExÃ©cutÃ© AVANT l'exÃ©cution proprement dite pour mÃ©thodes "is QtSignal"
    multi trait_mod:<is> (Routine $meth, :$QtSignal) is export
    {
        my Str $signature = methPosArgs2Str($meth.signature);
        my Str $class = $meth.signature.params[0].type.raku;
        my Bool $hasSimpleSig = $signature (elem) $simpleSignatures;

        # Look for an already registered signal
        my SigSlot $ss;
        if %signals{$class}:exists {
            for %signals{$class} -> $s {
                if $s.name eq $meth.name && $s.sig eq $signature {
                    $ss = $s;
                    last;
                }
            }
        }

        # If the signal is already registered (is a plainQt one) do nothing
        # else register it
        if !$ss {
            %signals{$class}.push(SigSlot.new(
                    name => $meth.name,
                    sig => $signature,
                    sigIsSimple => $hasSimpleSig,
                    sSignature =>
                            createSignature($meth.signature),
                    isPlainQt => False,
                    isSlot => False));
        }

# say "METH SIGNAL : ", $meth.name,
#     "   Signature : ", $meth.signature.params,
#     "   Soit : ", $signature;

        $meth.wrap: -> $f, |a {
            $f.qtEmit($meth.name, a, $signature, $hasSimpleSig)
        };
    }
    ##################################################################

    ##################################################################
    ### ExÃ©cutÃ© AVANT l'exÃ©cution proprement dite pour mÃ©thodes "is QtPrivateSignal"
    multi trait_mod:<is> (Routine $meth, :$QtPrivateSignal) is export
    {
        my Str $signature = methPosArgs2Str($meth.signature);
        my Str $class = $meth.signature.params[0].type.raku;
        my Bool $hasSimpleSig = $signature (elem) $simpleSignatures;

        # Private signals should ALWAYS be plain Qt
        #  ==> Too much code here ???

        # Look for an already registered signal
        my SigSlot $ss;
        if %signals{$class}:exists {
            for %signals{$class} -> $s {
                if $s.name eq $meth.name && $s.sig eq $signature {
                    $ss = $s;
                    last;
                }
            }
        }

        # If the signal is already registered (is a plainQt one) do nothing
        # else register it
        if !$ss {
            %signals{$class}.push(SigSlot.new(
                    name => $meth.name,
                    sig => $signature,
                    sigIsSimple => $hasSimpleSig,
                    sSignature =>
                            createSignature($meth.signature),
                    isPlainQt => False,
                    isSlot => False,
                    isPrivate => True));
        }


# say "METH PRIVATE SIGNAL : ", $meth.name,
#     "   Signature : ", $meth.signature.params,
#     "   Soit : ", $signature;

        $meth.wrap: -> $f, |a {
            $f.qtEmit($meth.name, a, $signature, $hasSimpleSig)
        };
    }
    ##################################################################

    ##################################################################
    ### ExÃ©cutÃ© AVANT l'exÃ©cution proprement dite pour mÃ©thodes "is QtSlot"
    multi trait_mod:<is> (Routine $meth, :$QtSlot) is export
    {
#         say "SLOT : ", $meth.name;

        my Str $signature = methPosArgs2Str($meth.signature);
        my Str $class = $meth.signature.params[0].type.^name;
        $class ~~ s:g/<[\(\)]>**1//; # Can't use .type.raku if .type is a stub
        my Bool $hasSimpleSig = $signature (elem) $simpleSignatures;

        # Look for an already registered slot
        my SigSlot $ss;
        if %slots{$class}:exists {
            for %slots{$class} -> $s {
                if $s.name eq $meth.name && $s.sig eq $signature {
                    $ss = $s;
                    last;
                }
            }
        }

        # If the slot is already registered (is a plainQt one) do nothing
        # else register it
        if !$ss {
            %slots{$class}.push(SigSlot.new(
                    name => $meth.name,
                    sig => $signature,
                    sigIsSimple => $hasSimpleSig,
                    sSignature =>
                            createSignature($meth.signature),
                    isPlainQt => False,
                    isSlot => True));
        }

#         %slots{$class}.push(SigSlot.new(name => $meth.name,
#                                           sig => $signature,
#                                           sigIsSimple => $hasSimpleSig,
#                                           rSignature =>
#                                                 removeInvocant($meth.signature),
#                                           isPlainQt => $class (elem) $qtClasses,
#                                           isSlot => True));

# say "METH SLOT : ", $meth.name,
#     "   Signature : ", $meth.signature.params,
#     "   Soit : ", $signature;

    }


#     submethod TWEAK {
#         say ::?CLASS, " TWEAK";
#     }

}



############################################################################
############################################################################



# For debug
sub showSigsSlots is export {
    say "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
    say "SIGNALS :";
    for %signals.kv -> $k, $v {
        say "   ", $k, "\t:";
        for @$v -> $u {
            say "\t", $u.name, " ", $u.sig, " ", $u.sigIsSimple;
        }
    }
    say "SLOTS :";
    for %slots.kv -> $k, $v {
        say "   ", $k, "\t:";
        for @$v -> $u {
            say "\t", $u.name, " ", $u.sig, " ", $u.sigIsSimple;
        }
    }
    say "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
}






import Sigsloty;

# Object with a related object in Qt library
class QtObject is Sigsloty is export {

    has int32 $.id;

    # Pointers to C++ objects "connectors" : for local classes only
    has %.emitters;
    has %.receivers;

    submethod TWEAK {
        $!id = $CM.addObj(self);

        %!emitters = ();
        %!receivers = ();

        # Ordered list of the current class and its parents
        my @classNames = (self.^name);
        for self.^parents -> $p {
            @classNames.push($p.^name);
        }

        # Look for defined signals and instantiate ConnectorE C++ objects
#         say " SIGNALS :";
        for @classNames -> $c {
            next if $c (elem) $qtClasses; # Qt classes don't need connectors
            if %signals{$c}:exists {
                for @(%signals{$c}) -> $s {
                    my ($signal, $signature) = ($s.name, $s.sig);
                    my $sigSigStr = $signal ~ $signature;
                    last if %!emitters{$sigSigStr}:exists; # Signal is verridden
#                     say "    > ", $signal, " : ", $signature;
#                     say "before QWConnectorECTOR";
                    my Pointer $p = QWConnectorECTOR($!id, $signal, $signature);
#                     say "after QWConnectorECTOR p = 0x", QWPointer2Int($p).base(16);
                    %!emitters{$sigSigStr} = $p;
                }
            }
        }

        # Look for defined slots and instantiate ConnectorR C++ objects
#         say " SLOTS :";
        for @classNames -> $c {
           next if $c (elem) $qtClasses; # Qt classes don't need connectors
           if %slots{$c}:exists {
                for @(%slots{$c}) -> $s {
                    my ($slot, $signature) = ($s.name, $s.sig);
                    my $slotSigStr = $slot ~ $signature;
                    last if %!receivers{$slotSigStr}:exists; # Slot is verridden
#                     say "    > ", $slot, " : ", $signature;
                    my Pointer $p = QWConnectorRCTOR($!id, $slot, $signature);
#                     say "after QWConnectorRCTOR p = 0x", QWPointer2Int($p).base(16);
                    %!receivers{$slotSigStr} = $p;
                }
            }
        }
    }


    submethod DESTROY
    {
        for %!emitters.values -> $e {
            QWConnectorEDTOR($e);
        }
        for %!receivers.values -> $r {
            QWConnectorRDTOR($r);
        }
    }



    # TODO TODO TODO : What if called on a Qt object ???
    method qtEmit(Str $signalName, Capture $values, Str $sigStr, Bool $simpleSig)
    {
#         say "Perl qtEmit : signalName=", $signalName, " values=", $values;
#         say "              SigStr=", $sigStr, " simpleSig=", $simpleSig;

        my Pointer $srcObj = %!emitters{$signalName ~ $sigStr};
#         say "XXXX srcObj = ", $srcObj;

        # Is the signal signature a simple one ?
        if $simpleSig {
            # Simple signature signal
#             say "Before switch";
#
#             for %!emitters.kv -> $k, $v {
#                 say "\"", $k, "\" : \"", $v, "\"";
#             }
            
            
            # Beware of the order : Bool must be placed before Int
            given $values {
                when :() {
#                     say "Switch () branch";
                    # QWEmit_(self.address, $signalName);
                    QWEmit_($srcObj, "QWSignal()");
                }
                when :(Bool) {
                    my int $val = (|$values)[0] ?? 1 !! 0;
#                     say "Before calling QWEmit_Bool";
#                     say "   signalName = ", $signalName;
#                     say "   values = ", $values;
#                     say "   val = ", $val;
                    my int64 $p = QWPointer2Int($srcObj);
#                     say "   ptr = Ox", $p.base(16);
                 #   QWEmit_Bool($srcObj, $signalName ~ $sigStr, $val);
                    QWEmit_Bool($srcObj, "QWSignal(bool)", $val);
                }
                when :(Int) { 
#                     say "Switch (Int) branch";
                    QWEmit_Int($srcObj, "QWSignal(int)", |$values);
                }
                when :(Str) {
#                     say "Switch (Str) branch";
                    QWEmit_Str($srcObj, "QWSignal(QString)", |$values);
                }
                default {
                    note "Signature of ", $values, " not found";
                }
            }
            
        } else {
            # Complex data mode, local to local message

            # Get the signal key
            
            #???????????????
            # my $keySig = self.id ~ $signalName ~ cap2sigStr($values);
            my $keySig = self.id ~ $signalName ~ $sigStr;
            
            # say "KEYSIG = >", $keySig, "<";

            my $connCount = $CM.signalConnections($keySig);
            if !$connCount {
                note "qtEmit: Signal with key \"$keySig\" isn't connected";
                return;
            }

            my int $dataId = $CM.addData($values, $connCount);

#             say "Emit signal with dataId = $dataId";
            QWEmit_Int($srcObj, "QWLocalToLocalSignal(int)", $dataId);
        }
    }


    # Attention : nommer cette methode "dump" entraÃ®ne une boucle infinie !
    method display {
        for %!emitters.kv -> $k, $v {
            say "\tSIGNAL ", $k, " : \t0x", QWPointer2Int($v).base(16);
        }
        for %!receivers.kv -> $k, $v {
            say "\tSLOT   ", $k, " : \t0x", QWPointer2Int($v).base(16);
        }
    }

}


##############################################################################


sub QWconnect(Pointer, Str, Pointer, Str) is native(&libwrapper) { * }

sub QWdisconnect(Pointer, Str, Pointer, Str) is native(&libwrapper) { * }


class ConnectionsManager {

    # key = connection_Id
    # value = reference to the object
    has %.objs is rw;
    my $lastConnId = 0;
    has Semaphore $!objLock;

    # key = srcObjId ~ signalName ~ signalSignature
    # value = How many times a signal is connected
    has %!sigConn;          
    has Semaphore $!sigLock;

    # key = event id
    # value = data object (data, count)
    has %!sigData;
    has Semaphore $!dataLock;


    my $lastEventId = 0;
    
    submethod TWEAK {
        $!objLock = Semaphore.new(1);
        $!sigLock = Semaphore.new(1);
        $!dataLock = Semaphore.new(1);
    }

    method dump {
        say "CM OBJS :";
        for %.objs.kv -> $x, $y {
            say "   $x :\t$y", "\t 0x", QWPointer2Int($y.address).base(16);
            $y.display;
        }
        say "CM SIGCONN :";
        for %!sigConn.kv -> $x, $y {
            say "   $x :\t$y";
        }
#          say "CM SIGDATA :";
#         for %!sigConn.kv -> $x, $y {
#             say "   $x :\t$y";
#         }
   }

    method addSignalConnection($signalKey)
    {
        $!sigLock.acquire;
            if %!sigConn{$signalKey}:exists {
                %!sigConn{$signalKey}++;
            } else {
                %!sigConn{$signalKey} = 1;
            }
        $!sigLock.release;
    }

    method rmSignalConnection($signalKey)
    {
        $!sigLock.acquire;
            if %!sigConn{$signalKey}:exists && %!sigConn{$signalKey} != 0 {
                %!sigConn{$signalKey}--;
            } else {
                note "Can't remove non-existent connection \"",
                                                        $signalKey, "\" ";
            }
        $!sigLock.release;
    }

    method signalConnections($signalKey) returns Int {
        # say '$CM.signalConnections key=', $signalKey;
        my $val;
        $!sigLock.acquire;
            if %!sigConn{$signalKey}:exists {
                $val = %!sigConn{$signalKey};
            } else {
                $val = 0;
            }
        $!sigLock.release;
        return $val;
    }


    # TODO : $obj are added, but never removed !!!!!!!
    method addObj(QtObject $obj) returns Int {
        $!objLock.acquire;
            %!objs{++$lastConnId} = $obj;
        $!objLock.release;
        return $lastConnId;
    }
    
    # TODO : This method should be called in the DESTROY submethods ! TODO
    method removeObj(Int $id) {
        $!objLock.acquire;
            if %!objs{$id}:exists {
                %!objs{$id}:delete;
            }
        $!objLock.release;
        return $lastConnId;
    }


    class Data
    {
        has Capture $.data;
        has Int $.count is rw;
    }


    method addData (Capture $data, Int $count) returns Int
    {
        $!dataLock.acquire;
            my $id = ++$lastEventId;
            %!sigData{$id} = Data.new(data => $data, count => $count);
        $!dataLock.release;
        return $id;
    }

    method getData(Int $id) # returns (Capture, Bool) # HOW TO DECLARE IT ???
    {
        # say "getData : id = $id";
    
        my @r;
        $!dataLock.acquire;
            if %!sigData{$id}:exists {
                my Int $c = %!sigData{$id}.count;
                my Capture $d = %!sigData{$id}.data;
                $c--;
                if $c {
                    %!sigData{$id}.count = $c;
                } else {
                    %!sigData{$id}:delete;
                }
                @r = ($d, True);
            } else {
                @r = (Nil, False);
            }
        $!dataLock.release;
        return @r;
    }
}



#`{{

ATTTENTION : Ce qui est ecrit plus bas n'est plus exact :
     Une classe ConnectorR (C++ seulement) est maintenant crÃ©Ã©e pour
     chacun des slots dÃ©finis au moment de l'instantiation d'une classe QtObject.



Une nouvelle instance de la classe ConnectorR (C++ seulement) est crÃ©Ã©e
Ã  chaque connect vers un objet Perl6.

L'objet Perl6 (ou, plutÃ´t, son Id) et le slot ce cet objet sont passÃ©s
au Connector Ã  sa crÃ©ation.

La connexion Qt est faite Ã  un slot standard (recepteur, ou qqchose
comme Ã§a) du Connector.
Ce slot standard appelle ensuite le slot de l'objet Perl6 via la
callback slotCaller().

   --> La classe connector ci-dessus est uniquement dÃ©finie en C++
       mais elle est crÃ©Ã©e/dÃ©truite depuis Perl
    ==> Seules les fonctions natives associÃ©es CTOR/DTOR sont dÃ©finies ici

}}


sub QWConnectorRCTOR(int32, Str, Str) returns Pointer
    is native(&libwrapper) { * }

sub QWConnectorRDTOR(Pointer)
    is native(&libwrapper) { * }


sub QWConnectorECTOR(int32, Str, Str) returns Pointer
    is native(&libwrapper) { * }

sub QWConnectorEDTOR(Pointer)
    is native(&libwrapper) { * }



#####################################################################"
###   > 24/12/2019 :
###   On va utiliser la chaine  "SIGSLOTNAME(QSIGNATURE)"
###   comme indice des maps ...
#####################################################################"




sub connect(Sigsloty $src, $sigName, Sigsloty $dst, $slotName)
        is export
{
    my Bool $simple;  # True if signature is "simple"

#     say "    signalStrSig = \"$signalStrSig\"";
#     say "    slotStrSig = \"$slotStrSig\"";

    my SigSlot $source;
    my SigSlot $destination;

    # Does the specified signal exist ?
    # Look not only in the given class, but also in all its parents
    my @classNames = ($src.^name);
#     say "CLASSLIST (", $src.^name, ")";
    for $src.^parents -> $p {
#         say "\t\t", $p.^name;
        @classNames.push($p.^name);
    }
    SIGLOOP: for @classNames -> $className {
        if %signals{$className}:exists {
            for @(%signals{$className}) -> $v {
                if $v.name ~~ $sigName {
                    $source = $v;
                    last SIGLOOP;
                }
            }
        }
    }
    if !$source {
        die "connect : signal ", $src.^name, ".", $sigName, " not found";
    }

    # Does the specified slot exist ?
    # Look not only in the given class, but also in all its parents
    @classNames = ($dst.^name);
    for $dst.^parents -> $p {
        @classNames.push($p.^name);
    }
    SLOTLOOP: for @classNames -> $className {
        if %slots{$className}:exists {
            for @(%slots{$className}) -> $v {
                if $v.name ~~ $slotName {
                    $destination = $v;
                    $simple = $v.sigIsSimple;
                    last SLOTLOOP;
                }
            }
        }
    }

    if !$destination {
        # Maybe the destination is a signal
        SIGLOOP2: for @classNames -> $className {
            if %signals{$className}:exists {
                for @(%signals{$className}) -> $v {
                    if $v.name ~~ $slotName {
                        $destination = $v;
                        $simple = $v.sigIsSimple;
                        last SIGLOOP2;
                    }
                }
            }
        }
    }

    if !$destination {
        die "connect : destination slot or signal ",
                            $dst.^name, ".", $slotName, " not found";
    }

    # Is destination a private signal ?
    if $destination.isPrivate {
        die "can't connect to private signal ",
                        $dst.^name, ".", $slotName, $destination.sig;
    }

    # Are source and destination compatible ?
    my $nbp = $destination.sSignature.accepts($source.sSignature);
    # say "NBP = $nbp";
    if $nbp < 0 {
        my Str $destNature = $destination.isSlot ?? "slot" !! "signal";
        die "connect : incompatible source and destination\n",
            "source is signal ", $src.^name, "::", $sigName, $source.sig,
            " [", $source.sSignature.str, "]\n",
            "destination is $destNature ", $dst.^name, "::", $slotName, $destination.sig,
            " [", ~$destination.sSignature.str, "]\n";
    }

    my $slotStrSig = $destination.sig;
    my $slotStrQSig = $destination.qSig;
    # Modify destination signatures if needed
    if $simple && $nbp > 0 {
        $slotStrSig = removeArgs($slotStrSig, $nbp);
        $slotStrQSig = removeArgs($slotStrSig, $nbp);
    }

    # create the connexion

    my Pointer $srcObj = Nil;
    my Pointer $dstObj = Nil;
    my Str $signal = "???";
    my Str $slot = "???";

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!! ATTENTION : Il faut ici definir EXACTEMENT quels sont les arguments
    #                attendus par QWconnect et comment fonctionnent les
    #                maps/hash utilisÃ©s....
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    if $simple {
        # Plusieurs cas a etudier...
        if $source.isPlainQt {
            $srcObj = $src.address;
            $signal = $sigName ~ $source.qSig;
        } else {
            $srcObj = $src.emitters{$sigName ~ $source.sig};
            $signal = "QWSignal" ~ %qSigSig{$source.sig};
        }
        if $destination.isPlainQt {
            $dstObj = $dst.address;
            $slot = $slotName ~ $slotStrQSig;
        } else {
            if $destination.isSlot {
                $dstObj = $dst.receivers{$slotName ~ $slotStrSig};
                $slot = "QWSlot" ~ %qSigSig{$slotStrSig};
            } else {
                $dstObj = $dst.emitters{$slotName ~ $slotStrSig};
                $slot = "QWSignal" ~ %qSigSig{$slotStrSig};
            }
        }

    } else {
        # Local to local connexion, with use of the cache :
        # Neither source nor destination are pure Qt widgets
        # Data will be kept inside perl space and identified with
        # a unique data key.
        # This key will be send instead of the data.

        # The following key identifies the source of the connection
        my $keySig = $src.id ~ $sigName ~ $source.sig;
        # say "KEYSIG = ", $keySig;

        # Count connexions. This count is needed to remove the data
        # when all the connexions have been used.
        $CM.addSignalConnection($keySig);

        $signal = "QWSignal(int)";
        $slot = "QWLocalToLocalSlot(int)";
        $srcObj = $src.emitters{$sigName ~ $source.sig};
        $dstObj = $dst.receivers{$slotName ~ $destination.sig};
    }

    # say "CONNECT : $signal --> $slot";

    # Then connect inside Qt
    QWconnect($srcObj, $signal, $dstObj, $slot);
}

#------------------------------------------------------------------



sub disconnect(Sigsloty $src, $sigName, Sigsloty $dst, $slotName)
        is export
{
    my Bool $simple;  # True if signature is "simple"

#     say "    signalStrSig = \"$signalStrSig\"";
#     say "    slotStrSig = \"$slotStrSig\"";

    my SigSlot $source;
    my SigSlot $destination;

    # Does the specified signal exist ?
    # Look not only in the given class, but also in all its parents
    my @classNames = ($src.^name);
#     say "CLASSLIST (", $src.^name, ")";
    for $src.^parents -> $p {
#         say "\t\t", $p.^name;
        @classNames.push($p.^name);
    }
    SIGLOOP: for @classNames -> $className {
        if %signals{$className}:exists {
            for @(%signals{$className}) -> $v {
                if $v.name ~~ $sigName {
                    $source = $v;
                    last SIGLOOP;
                }
            }
        }
    }
    if !$source {
        die "disconnect : signal ", $src.^name, ".", $sigName, " not found";
    }

    # Does the specified slot exist ?
    # Look not only in the given class, but also in all its parents
    @classNames = ($dst.^name);
    for $dst.^parents -> $p {
        @classNames.push($p.^name);
    }
    SLOTLOOP: for @classNames -> $className {
        if %slots{$className}:exists {
            for @(%slots{$className}) -> $v {
                if $v.name ~~ $slotName {
                    $destination = $v;
                    $simple = $v.sigIsSimple;
                    last SLOTLOOP;
                }
            }
        }
    }

    if !$destination {
        # Maybe the destination is a signal
        SIGLOOP2: for @classNames -> $className {
            if %signals{$className}:exists {
                for @(%signals{$className}) -> $v {
                    if $v.name ~~ $slotName {
                        $destination = $v;
                        $simple = $v.sigIsSimple;
                        last SIGLOOP2;
                    }
                }
            }
        }
    }

    if !$destination {
        die "disconnect : destination slot or signal ",
                            $dst.^name, ".", $slotName, " not found";
    }

    # Is destination a private signal ?
    if $destination.isPrivate {
        die "can't be connected to a private signal ",
                        $dst.^name, ".", $slotName, $destination.sig;
    }

    # Are source and destination compatible ?
    my $nbp = $destination.sSignature.accepts($source.sSignature);
    # say "NBP = $nbp";
    if $nbp < 0 {
        my Str $destNature = $destination.isSlot ?? "slot" !! "signal";
        die "disconnect : incompatible source and destination\n",
            "source is signal ", $src.^name, "::", $sigName, $source.sig,
            " [", $source.sSignature.str, "]\n",
            "destination is $destNature ", $dst.^name, "::", $slotName, $destination.sig,
            " [", ~$destination.sSignature.str, "]\n";
    }

    my $slotStrSig = $destination.sig;
    my $slotStrQSig = $destination.qSig;
    # Modify destination signatures if needed
    if $simple && $nbp > 0 {
        $slotStrSig = removeArgs($slotStrSig, $nbp);
        $slotStrQSig = removeArgs($slotStrSig, $nbp);
    }

    # remove the connexion

    my Pointer $srcObj = Nil;
    my Pointer $dstObj = Nil;
    my Str $signal = "???";
    my Str $slot = "???";


    if $simple {
        # Plusieurs cas a etudier...
        if $source.isPlainQt {
            $srcObj = $src.address;
            $signal = $sigName ~ $source.qSig;
        } else {
            $srcObj = $src.emitters{$sigName ~ $source.sig};
            $signal = "QWSignal" ~ %qSigSig{$source.sig};
        }
        if $destination.isPlainQt {
            $dstObj = $dst.address;
            $slot = $slotName ~ $slotStrQSig;
        } else {
            if $destination.isSlot {
                $dstObj = $dst.receivers{$slotName ~ $slotStrSig};
                $slot = "QWSlot" ~ %qSigSig{$slotStrSig};
            } else {
                $dstObj = $dst.emitters{$slotName ~ $slotStrSig};
                $slot = "QWSignal" ~ %qSigSig{$slotStrSig};
            }
        }

    } else {
        # Local to local connexion, with use of the cache :
        # Neither source nor destination are pure Qt widgets
        # Data will be kept inside perl space and identified with
        # a unique data key.
        # This key will be send instead of the data.

        # The following key identifies the source of the connection
        my $keySig = $src.id ~ $sigName ~ $source.sig;
#         say "KEYSIG = ", $keySig;

# TODO TODO TODO
#         # Count connexions. This count is needed to remove the data
#         # when all the connexions have been used.
#         $CM.addSignalConnection($keySig);

        $signal = "QWSignal(int)";
        $slot = "QWLocalToLocalSlot(int)";
        $srcObj = $src.emitters{$sigName ~ $source.sig};
        $dstObj = $dst.receivers{$slotName ~ $destination.sig};
    }

    # say "CONNECT : $signal --> $slot";

    # Then connect inside Qt
    QWdisconnect($srcObj, $signal, $dstObj, $slot);
}

#------------------------------------------------------------------





#######################################

# constant INTSIZE = 32;
#
# macro STD_INT {
#     if INTSIZE == 32 {
#         quasi { int32 };
#     } else {
#         quase { int64 };
#     }
# }

sub slotCallback(int32 $objectId, Str $slotName)
{
    $CM.objs{$objectId}."$slotName"();
}

sub slotCallbackInt(int32 $objectId, Str $slotName, int64 $i)
{
    $CM.objs{$objectId}."$slotName"($i);
}

sub slotCallbackInt2(int32 $objectId, Str $slotName, int64 $i1, int64 $i2)
{
    $CM.objs{$objectId}."$slotName"($i1, $i2);
}

sub slotCallbackStr(int32 $objectId, Str $slotName, Str $s)
{
# say "   *** slotCallbackStr slotName=$slotName s=$s";
    $CM.objs{$objectId}."$slotName"($s);
}

sub slotCallbackIntStr(int32 $objectId, Str $slotName, int64 $i, Str $s)
{
    $CM.objs{$objectId}."$slotName"($i, $s);
}

sub slotCallbackBool(int32 $objectId, Str $slotName, int8 $b)
{
    $CM.objs{$objectId}."$slotName"(?$b);
}

sub slotCallbackPointer(int32 $objectId, Str $slotName, Pointer $p)
{
    # say "   *** slotCallbackPointer objid=$objectId slotName=$slotName ", $p;

    $CM.objs{$objectId}."$slotName"($p);
}

sub slotCallbackQEvent(int32 $objectId, Str $slotName, Pointer $event)
{
    my QEvent $a1 = QEvent.new($event);
    $CM.objs{$objectId}."$slotName"($a1)
}

sub slotCallbackQMouseEvent(int32 $objectId, Str $slotName, Pointer $event)
{
    my QMouseEvent $a1 = QMouseEvent.new($event);
    $CM.objs{$objectId}."$slotName"($a1)
}

sub slotCallbackQPaintEvent(int32 $objectId, Str $slotName, Pointer $event)
{
    my QPaintEvent $a1 = QPaintEvent.new($event);
    $CM.objs{$objectId}."$slotName"($a1)
}



sub slotCallbackComplexSig(int32 $objectId, Str $slotName, int32 $dataId)
{
    my ($capt, $ok) = $CM.getData($dataId);

    # say "Stack: " ~ Backtrace.new;
    # say "just before calling the slot ", $slotName;
    # say "ok = ", $ok;
    # say $capt.gist;
    # say "objectId : ", $objectId;
    # say $CM.objs{$objectId}.gist;

    if (!$ok) {
        note "INTERNAL ERROR: Data(Id=$dataId) not found in capture cache";
        # Should we die ???
        return;
    }
    $CM.objs{$objectId}."$slotName"(|$capt);
}



##############################################################################
# Start of code for QObject
# QObject is processed as a special case

class QObject is QtObject is export {
    method ctor { ... }
#     submethod TWEAK {
#         say ::?CLASS, " TWEAK";
#     }
}

# End of code for QObject
##############################################################################




###############################################################################
####### Part 2 : main API #####################################################

### Beginning of the main API part ###
class QWidget is QObject is QPaintDevice is export {
    enum RenderFlag (
        DrawWindowBackground => 1,
        DrawChildren => 2,
        IgnoreMask => 4,
    );
    our sub RenderFlags($e? = DrawWindowBackground --> Int ) is export { $e };
    CHECK {
        %callbacks{::?CLASS.raku} = <
            mousePressEvent
            mouseReleaseEvent
            mouseMoveEvent
            enterEvent
            leaveEvent
            paintEvent
        >;
    }
    multi sub ctor(QtBase $this, QWidget $parent = (QWidget), Int $f = Qt::WindowFlags()) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQWidgetCtor($a1, $f);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, QWidget $parent = (QWidget), Int $f = Qt::WindowFlags()) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQWidgetCtor($a1, $f);
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QWidget(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QWidget $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQWidgetDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method setDisabled(Bool $arg1) is QtSlot
    {
        my int8 $a1 = $arg1.Int;
        QWQWidgetsetDisabled(self.address, $a1);
    }
    method width( --> Int)
    {
        my $result = QWQWidgetwidth(self.address);
        return $result;
    }
    method height( --> Int)
    {
        my $result = QWQWidgetheight(self.address);
        return $result;
    }
    multi method setMinimumSize(Int $minw, Int $minh)
    {
        QWQWidgetsetMinimumSize_2(self.address, $minw, $minh);
    }
    multi method setFixedSize(Int $w, Int $h)
    {
        QWQWidgetsetFixedSize_2(self.address, $w, $h);
    }
    method setFixedWidth(Int $w)
    {
        QWQWidgetsetFixedWidth(self.address, $w);
    }
    method setFixedHeight(Int $h)
    {
        QWQWidgetsetFixedHeight(self.address, $h);
    }
    method font( --> QFont)
    {
        my $result = QWQWidgetfont(self.address);
        my $result1 = QFont.new($result, obr => False);
        return $result1;
    }
    method setFont(QFont $arg1)
    {
        my $a1 = $arg1.address;
        QWQWidgetsetFont(self.address, $a1);
    }
    multi method render(QPaintDevice $target, QPoint $targetOffset = QPoint.new(), QRegion $sourceRegion = QRegion.new(), Int $renderFlags = RenderFlags(DrawWindowBackground +| DrawChildren))
    {
        my $a1 = ?$target ?? $target.address !! QWInt2Pointer(0);
        my $a2 = $targetOffset.address;
        my $a3 = $sourceRegion.address;
        QWQWidgetrender_1(self.address, $a1, $a2, $a3, $renderFlags);
    }
    method setWindowTitle(Str $arg1) is QtSlot
    {
        QWQWidgetsetWindowTitle(self.address, $arg1);
    }
    method setToolTip(Str $arg1)
    {
        QWQWidgetsetToolTip(self.address, $arg1);
    }
    multi method setFocus() is QtSlot
    {
        QWQWidgetsetFocus_1(self.address);
    }
    method isActiveWindow( --> Bool)
    {
        my $result = QWQWidgetisActiveWindow(self.address);
        my $result1 = ?$result;
        return $result1;
    }
    method activateWindow()
    {
        QWQWidgetactivateWindow(self.address);
    }
    multi method setFocus(Qt::FocusReason $reason)
    {
        QWQWidgetsetFocus_2(self.address, $reason);
    }
    method setFocusPolicy(Qt::FocusPolicy $policy)
    {
        QWQWidgetsetFocusPolicy(self.address, $policy);
    }
    multi method update() is QtSlot
    {
        QWQWidgetupdate_1(self.address);
    }
    multi method update(Int $x, Int $y, Int $w, Int $h)
    {
        QWQWidgetupdate_2(self.address, $x, $y, $w, $h);
    }
    method show() is QtSlot
    {
        QWQWidgetshow(self.address);
    }
    method setLayout(QLayout $arg1)
    {
        my $a1 = ?$arg1 ?? $arg1.address !! QWInt2Pointer(0);
        QWQWidgetsetLayout(self.address, $a1);
    }
}

class QAbstractButton is QWidget is export {
    submethod new(|capture) is hidden-from-backtrace {
        unimplementedCtor("QAbstractButton");
    }
    method setText(Str $text)
    {
        QWQAbstractButtonsetText(self.address, $text);
    }
    method text( --> Str)
    {
        my $result = QWQAbstractButtontext(self.address);
        return $result;
    }
    method click() is QtSlot
    {
        QWQAbstractButtonclick(self.address);
    }
    method pressed()
        is QtSignal { ... }
    method clicked(Bool $checked = False)
        is QtSignal { ... }
}

class QAction is QObject is export {
    multi sub ctor(QtBase $this, QObject $parent = (QObject)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQActionCtor_1($a1);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, QObject $parent = (QObject)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQActionCtor_1($a1);
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QAction(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QAction $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQActionDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method trigger() is QtSlot
    {
        QWQActiontrigger(self.address);
    }
    method setEnabled(Bool $arg1) is QtSlot
    {
        my int8 $a1 = $arg1.Int;
        QWQActionsetEnabled(self.address, $a1);
    }
    method setDisabled(Bool $b) is QtSlot
    {
        my int8 $a1 = $b.Int;
        QWQActionsetDisabled(self.address, $a1);
    }
    method triggered(Bool $checked = False)
        is QtSignal { ... }
}

class QCoreApplication is QObject is export {
    submethod new(|capture) is hidden-from-backtrace {
        unimplementedCtor("QCoreApplication");
    }
    method sendEvent(QObject $receiver, QEvent $event --> Bool)
    {
        my $a1 = ?$receiver ?? $receiver.address !! QWInt2Pointer(0);
        my $a2 = ?$event ?? $event.address !! QWInt2Pointer(0);
        my $result = QWQCoreApplicationsendEvent(self.address, $a1, $a2);
        my $result1 = ?$result;
        return $result1;
    }
    method quit() is QtSlot
    {
        QWQCoreApplicationquit(self.address);
    }
}

class QFrame is QWidget is export {
    submethod new(|capture) is hidden-from-backtrace {
        unimplementedCtor("QFrame");
    }
}

class QLayout is QObject is QLayoutItem is export {
    submethod new(|capture) is hidden-from-backtrace {
        unimplementedCtor("QLayout");
    }
    multi method setAlignment(QWidget $w, Int $alignment --> Bool)
    {
        my $a1 = ?$w ?? $w.address !! QWInt2Pointer(0);
        my $result = QWQLayoutsetAlignment_1(self.address, $a1, $alignment);
        my $result1 = ?$result;
        return $result1;
    }
    multi method setAlignment(QLayout $l, Int $alignment --> Bool)
    {
        my $a1 = ?$l ?? $l.address !! QWInt2Pointer(0);
        my $result = QWQLayoutsetAlignment_2(self.address, $a1, $alignment);
        my $result1 = ?$result;
        return $result1;
    }
    method addWidget(QWidget $w)
    {
        my $a1 = ?$w ?? $w.address !! QWInt2Pointer(0);
        QWQLayoutaddWidget(self.address, $a1);
    }
}

class QLineEdit is QWidget is export {
    multi sub ctor(QtBase $this, QWidget $parent = (QWidget)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQLineEditCtor_1($a1);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, QWidget $parent = (QWidget)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQLineEditCtor_1($a1);
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QLineEdit(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, Str $arg1, QWidget $parent = (QWidget)) {
        my $a2 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQLineEditCtor_2($arg1, $a2);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, Str $arg1, QWidget $parent = (QWidget)) {
        my $a2 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQLineEditCtor_2($arg1, $a2);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QLineEdit $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQLineEditDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method text( --> Str)
    {
        my $result = QWQLineEdittext(self.address);
        return $result;
    }
    method setAlignment(Int $flag)
    {
        QWQLineEditsetAlignment(self.address, $flag);
    }
    method setText(Str $arg1) is QtSlot
    {
        QWQLineEditsetText(self.address, $arg1);
    }
    method clear() is QtSlot
    {
        QWQLineEditclear(self.address);
    }
    method returnPressed()
        is QtSignal { ... }
    method editingFinished()
        is QtSignal { ... }
}

class QMenu is QWidget is export {
    multi sub ctor(QtBase $this, QWidget $parent = (QWidget)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQMenuCtor_1($a1);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, QWidget $parent = (QWidget)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQMenuCtor_1($a1);
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QMenu(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, Str $title, QWidget $parent = (QWidget)) {
        my $a2 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQMenuCtor_2($title, $a2);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, Str $title, QWidget $parent = (QWidget)) {
        my $a2 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQMenuCtor_2($title, $a2);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QMenu $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQMenuDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    multi method addAction(Str $text --> QAction)
    {
        my $result = QWQMenuaddAction_1(self.address, $text);
        my $result1 = QAction.new($result, obr => False);
        return $result1;
    }
    multi method exec( --> QAction)
    {
        my $result = QWQMenuexec_1(self.address);
        my $result1 = QAction.new($result, obr => False);
        return $result1;
    }
}

class QTimer is QObject is export {
    multi sub ctor(QtBase $this, QObject $parent = (QObject)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQTimerCtor($a1);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, QObject $parent = (QObject)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQTimerCtor($a1);
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QTimer(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QTimer $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQTimerDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    multi method setInterval(Int $msec)
    {
        QWQTimersetInterval_1(self.address, $msec);
    }
    multi method start() is QtSlot
    {
        QWQTimerstart_2(self.address);
    }
    method stop() is QtSlot
    {
        QWQTimerstop(self.address);
    }
    method timeout()
        is QtPrivateSignal { ... }
}

class QAbstractScrollArea is QFrame is export {
    submethod new(|capture) is hidden-from-backtrace {
        unimplementedCtor("QAbstractScrollArea");
    }
}

class QBoxLayout is QLayout is export {
    submethod new(|capture) is hidden-from-backtrace {
        unimplementedCtor("QBoxLayout");
    }
    method addLayout(QLayout $layout, Int $stretch = 0)
    {
        my $a1 = ?$layout ?? $layout.address !! QWInt2Pointer(0);
        QWQBoxLayoutaddLayout(self.address, $a1, $stretch);
    }
}

class QGuiApplication is QCoreApplication is export {
    submethod new(|capture) is hidden-from-backtrace {
        unimplementedCtor("QGuiApplication");
    }
}

class QLabel is QFrame is export {
    multi sub ctor(QtBase $this, QWidget $parent = (QWidget), Int $f = Qt::WindowFlags()) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQLabelCtor_1($a1, $f);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, QWidget $parent = (QWidget), Int $f = Qt::WindowFlags()) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQLabelCtor_1($a1, $f);
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QLabel(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, Str $text, QWidget $parent = (QWidget), Int $f = Qt::WindowFlags()) {
        my $a2 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQLabelCtor_2($text, $a2, $f);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, Str $text, QWidget $parent = (QWidget), Int $f = Qt::WindowFlags()) {
        my $a2 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQLabelCtor_2($text, $a2, $f);
        $this.ownedByRaku = True;
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QLabel $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQLabelDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method setTextFormat(Qt::TextFormat $arg1)
    {
        QWQLabelsetTextFormat(self.address, $arg1);
    }
    method setAlignment(Int $arg1)
    {
        QWQLabelsetAlignment(self.address, $arg1);
    }
    method setMargin(Int $arg1)
    {
        QWQLabelsetMargin(self.address, $arg1);
    }
    method setText(Str $arg1) is QtSlot
    {
        QWQLabelsetText(self.address, $arg1);
    }
    method clear() is QtSlot
    {
        QWQLabelclear(self.address);
    }
}

class QPushButton is QAbstractButton is export {
    multi sub ctor(QtBase $this, Str $text, QWidget $parent = (QWidget)) {
        my $a2 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQPushButtonCtor_2($text, $a2);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, Str $text, QWidget $parent = (QWidget)) {
        my $a2 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQPushButtonCtor_2($text, $a2);
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QPushButton(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QPushButton $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQPushButtonDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method setMenu(QMenu $menu)
    {
        my $a1 = ?$menu ?? $menu.address !! QWInt2Pointer(0);
        QWQPushButtonsetMenu(self.address, $a1);
    }
}

class QHBoxLayout is QBoxLayout is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQHBoxLayoutCtor_1();
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this) {
        $this.address = SCWQHBoxLayoutCtor_1();
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QHBoxLayout(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QHBoxLayout $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQHBoxLayoutDtor(self.address);
            self.ownedByRaku = False;
        }
    }
}

class QTextEdit is QAbstractScrollArea is export {
    multi sub ctor(QtBase $this, QWidget $parent = (QWidget)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = QWQTextEditCtor_1($a1);
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this, QWidget $parent = (QWidget)) {
        my $a1 = ?$parent ?? $parent.address !! QWInt2Pointer(0);
        $this.address = SCWQTextEditCtor_1($a1);
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QTextEdit(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QTextEdit $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQTextEditDtor(self.address);
            self.ownedByRaku = False;
        }
    }
    method toPlainText( --> Str)
    {
        my $result = QWQTextEdittoPlainText(self.address);
        return $result;
    }
}

class QVBoxLayout is QBoxLayout is export {
    multi sub ctor(QtBase $this) {
        $this.address = QWQVBoxLayoutCtor_1();
        $this.ownedByRaku = True;
    }
    multi sub subClassCtor(QtBase $this) {
        $this.address = SCWQVBoxLayoutCtor_1();
        $this.ownedByRaku = True;
    }
    method validateCB(Str $m) {
        QWvalidateCB_QVBoxLayout(self.address, self.id, $m);
    }
    multi sub ctor(QtBase $this, NativeCall::Types::Pointer $p, Bool :$obr = False) {
        # Get access to a preexisting Qt object
        $this.address = $p;
        $this.ownedByRaku = $obr;
    }
    multi sub ctor(|capture) {
        note "QtWidgets ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod new(|capture) {
        my QVBoxLayout $rObj = self.bless;
        ctor($rObj, |capture);
        return $rObj;
    }
    multi sub subClassCtor(|capture) {
        note "QtWidgets subclass ", ::?CLASS.^name,
             " ctor called with unsupported args";
        die "Bad args";
    }
    submethod subClass(|capture) {
        subClassCtor(self, |capture);
        self.validateCallBacks();
    }
    submethod DESTROY {
        if self.ownedByRaku {
            QWQVBoxLayoutDtor(self.address);
            self.ownedByRaku = False;
        }
    }
}
### End of the main API part ###



##############################################################################
##############################################################################
# Start of code for QApplication
# QApplication is used to initialize RaQt and hence is a special case


sub QWApplicationCtor(int32, CArray[Str])
        returns Pointer is native(&libwrapper) { * }

sub QWApplicationInstance() returns Pointer is export is native(&libwrapper) { * }

sub QWApplicationExec(Pointer) returns int32 is native(&libwrapper) { * }

class QApplication is QCoreApplication is export {

    # WARNING : Subclassing QApplication is currently unsupported

    multi sub ctor(QtBase $this, 
                    Str $progName = $*PROGRAM-NAME, @args = @*ARGS) {
                    
        # Reconstruction of C main arguments : (int argc, char **argv)
        # from $progName (argv[0]) and @args (the list of others argv[])
        my $argv = CArray[Str].new;
        $argv[0] = $progName;
        my $argc = 1;
        for @args -> $x {
            $argv[$argc++] = $x;
        }
                    
        # Call QApplication ctor
        $this.address = QWApplicationCtor($argc, $argv);
        $this.ownedByRaku = True;
    }

    multi sub ctor(|capture) {
        $QA = Nil;
        note "QApplication.new called with unsupported args";
        die "Bad args";
    }

    submethod new(|capture) {
        if $QA {
            die "QApplication can't have more than one instance";
        } else {
            setupEverything;
            my QApplication $rObj = self.bless;
            $QA = $rObj;
            ctor($rObj, |capture);
            return $rObj;
        }
    }


    sub setupEverything {
    
        # Start the connections manager if needed
        $CM = ConnectionsManager.new if !$CM;

        # Register the addresses of the callbacks
        QWSetupSlotCallback(&slotCallback);
        QWSetupSlotCallbackInt(&slotCallbackInt);
        QWSetupSlotCallbackInt2(&slotCallbackInt2);
        QWSetupSlotCallbackStr(&slotCallbackStr);
        QWSetupSlotCallbackIntStr(&slotCallbackIntStr);
        QWSetupSlotCallbackBool(&slotCallbackBool);
        QWSetupSlotCallbackPointer(&slotCallbackPointer);
# TODO        QWSetupSlotCallbackMouseEvent(&slotCallbackMouseEvent);
# TODO        QWSetupSlotCallbackQEvent(&slotCallbackQEvent);
        QWSetupSlotCallbackComplexSig(&slotCallbackComplexSig);

        QWSetupSlotCallbackQEvent(&slotCallbackQEvent);
        QWSetupSlotCallbackQMouseEvent(&slotCallbackQMouseEvent);
        QWSetupSlotCallbackQPaintEvent(&slotCallbackQPaintEvent);
    }

    method exec {
        return QWApplicationExec($.address);
    }

}

# End of code for QApplication
##############################################################################


sub QWDump()
        is native(&libwrapper) { * }


sub QtDump is export {
    say "DUMP " ~ "=" x 50;
    $CM.dump;
    QWDump();
    say "=" x 55;
}


##############################################################################
##############################################################################









